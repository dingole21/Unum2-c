#include "../include/penv.h"
#include "../include/pbound.h"
#include "../include/pfloat.h"
#include <stdio.h>

void pf_add(PBound *dest, PFloat lhs, PFloat rhs);
void pf_inexact_add(PBound *dest, PFloat lhs, PFloat rhs);
void pf_exact_add(PBound *dest, PFloat lhs, PFloat rhs);
void exact_arithmetic_addition(PBound *dest, PFloat lhs, PFloat rhs);


void add(PBound *dest, const PBound *lhs, const PBound *rhs){
  TRACK("entering add...")

  /*first handle all the corner cases*/
  if (isempty(lhs) || isempty(rhs)) {set_empty(dest); return;}
  if (isallpreals(lhs) || isallpreals(rhs)) {set_allreals(dest); return;}

  if (issingle(lhs) && issingle(rhs)) {pf_add(dest, lhs->lower, rhs->lower); return;}

  //assign proxy values because "single" doesn't have a meaningful upper value.
  PFloat lhs_upper_proxy = issingle(lhs) ? lhs->lower : lhs->upper;
  PFloat rhs_upper_proxy = issingle(rhs) ? rhs->lower : rhs->upper;

  //NB: consider going directly to "single_add" with a double single check.
  //go ahead and do both sides of the bound calculation.  Use a temporary variable.
  PBound temp = __EMPTYBOUND;
  dest->state = STDBOUND;
  pf_add(&temp, lhs->lower, rhs->lower);
  dest->lower = temp.lower;
  pf_add(&temp, lhs_upper_proxy, rhs_upper_proxy);
  dest->upper = temp.upper;
  collapseifsingle(dest);
}

void pf_add(PBound *dest, PFloat lhs, PFloat rhs){
  TRACK("entering pf_add...")

  if (is_pf_inf(lhs)) {set_inf(dest); return;}
  if (is_pf_inf(rhs)) {set_inf(dest); return;}
  if (is_pf_zero(lhs)) {set_single(dest, rhs); return;}
  if (is_pf_zero(rhs)) {set_single(dest, lhs); return;}

  if (is_pf_exact(lhs) && is_pf_exact(rhs)) {
    pf_exact_add(dest, lhs, rhs);
  } else {
    pf_inexact_add(dest, lhs, rhs);
  }
  return;
}

void pf_inexact_add(PBound *dest, PFloat lhs, PFloat rhs){
  TRACK("entering pf_inexact_add...")

  PBound temp = __EMPTYBOUND;
  pf_exact_add(&temp, glb(lhs), glb(rhs));
  PFloat _l = upper_ulp(temp.lower);
  pf_exact_add(&temp, lub(lhs), lub(rhs));
  PFloat _u = (temp.state == SINGLETON) ? lower_ulp(temp.lower) : lower_ulp(temp.upper);

  set_bound(dest, _l, _u);
  collapseifsingle(dest);
}

void exact_arithmetic_subtraction(PBound *dest, PFloat lhs, PFloat rhs);

void pf_exact_add(PBound *dest, PFloat lhs, PFloat rhs){
  TRACK("entering pf_exact_add...")

  //redo the checks on this in case we've been passed from inexact_add.

  if (is_pf_negative(lhs) ^ is_pf_negative(rhs)){
    exact_arithmetic_subtraction(dest, lhs, pf_additiveinverse(rhs));
  } else {
    exact_arithmetic_addition(dest, lhs, rhs);
  }
}

int addsub_index(long long lhs_lattice, long long rhs_lattice){
  //matrix points are generated by shifting away the ulp status.
  int lpoint1 = (lhs_lattice >> 1);
  int lpoint2 = (rhs_lattice >> 1);
  //shift the left value index by the number of lattice bits.
  return (lpoint1 << PENV->latticebits) + lpoint2;
}

void exact_arithmetic_addition(PBound *dest, PFloat lhs, PFloat rhs){
  TRACK("entering exact_arithmetic_addition...")

  if (is_pf_inf(lhs)) {set_inf(dest); return;}
  if (is_pf_inf(rhs)) {set_inf(dest); return;}
  if (is_pf_zero(lhs)) {set_single(dest, rhs); return;}
  if (is_pf_zero(rhs)) {set_single(dest, lhs); return;}

  int res_epoch = pf_epoch(lhs);
  unsigned long long res_lattice;
  unsigned long long lhs_lattice = pf_lattice(lhs);
  unsigned long long rhs_lattice = pf_lattice(rhs);

  if (is_pf_inverted(lhs) && is_pf_inverted(rhs)){
    if (res_epoch == pf_epoch(rhs)){
      res_lattice = (PENV->tables[__ADD_INVERTED_TABLE])[addsub_index(lhs_lattice, rhs_lattice)];
      res_epoch -= (res_lattice > lhs_lattice) ? 1 : 0;
    } else {
      //nothing, for now.
      return;
    }
  } else if ((!is_pf_inverted(lhs)) && (!is_pf_inverted(rhs))) {
    if (res_epoch == pf_epoch(rhs)){
      res_lattice = (PENV->tables[__ADD_TABLE])[addsub_index(lhs_lattice, rhs_lattice)];
      res_epoch += (res_lattice < lhs_lattice) ? 1 : 0;
    } else {
      //nothing, for now.
      return;
    }
  } else {  //lhs is not inverted, rhs is inverted.
    if ((res_epoch == 0) && (pf_epoch(rhs) == 0)) {
      res_lattice = (PENV->tables[__ADD_CROSSED_TABLE])[addsub_index(lhs_lattice, rhs_lattice)];
      res_epoch = (res_lattice < lhs_lattice) ? 1 : 0;
    } else {
      //nothing, for now.
      return;
    }
  }

  set_single(dest, pf_synth(is_pf_negative(lhs), is_pf_inverted(lhs), res_epoch, res_lattice));
  return;
}
