#include "../include/penv.h"
#include "../include/pbound.h"
#include "../include/ptile.h"
#include <stdio.h>

int addsub_index(long long lhs_lattice, long long rhs_lattice){
  //matrix points are generated by shifting away the ulp status.
  int lpoint1 = (lhs_lattice >> 1);
  int lpoint2 = (rhs_lattice >> 1);
  //shift the left value index by the number of lattice bits.
  return (lpoint1 << (PENV->latticebits - 1)) + lpoint2;
}

//addsub index when we have to consider moving between tables.
int table_addsub_index(int table, long long lhs_lattice, long long rhs_lattice){
  int lpoint1 = (lhs_lattice >> 1);
  int lpoint2 = (rhs_lattice >> 1);
  int tablewidth = (1 << (PENV->latticebits - 1));
  return table * tablewidth * tablewidth + (lpoint1 * tablewidth) + lpoint2;
}

static PTile exact_arithmetic_addition_crossed(__dc_tile *outer, __dc_tile *inner){
  int table = outer->epoch + inner->epoch;
  unsigned long long old_lattice = outer->lattice;

  if (table < PENV->table_counts[__ADD_CROSSED_TABLE]){
    outer->lattice = (PENV->tables[__ADD_CROSSED_TABLE])[table_addsub_index(table, outer->lattice, inner->lattice)];
    outer->epoch += (outer->lattice < old_lattice) ? 1 : 0;
    return tile_synth(outer);
  } else {
    return tile_synth(dc_lvup(outer));
  }
}

static PTile exact_arithmetic_addition_inverted(__dc_tile *outer, __dc_tile *inner){
  int table = inner->epoch - outer->epoch;
  int index = table_addsub_index(table, outer->lattice, inner->lattice);

  if (table < PENV->table_counts[__ADD_INVERTED_TABLE]) {
    outer->lattice = (PENV->tables[__ADD_INVERTED_TABLE])[index];

    outer->epoch -= (outer->lattice > inner->lattice) ? 1 : 0;
  } else if (outer->lattice != 0) {
    return tile_synth(dc_lvdn(outer));
  } else {
    outer->epoch -= 1;
    outer->lattice = (1 << PENV->latticebits) - 1;
  }

  if (outer->epoch < 0){
    outer->inverted = false;
    outer->epoch = 0;
    if (table < PENV->table_counts[__ADD_INVERTED_TABLE]) {
      outer->lattice = (PENV->tables[__INVERTED_ADD_INVERTED_TABLE])[index];
    } else {
      outer->lattice = 1;
    }
  }

  return tile_synth(outer);
}

static PTile exact_arithmetic_addition_uninverted(__dc_tile *outer, __dc_tile *inner){
  int table = outer->epoch - inner->epoch;

  if (table < PENV->table_counts[__ADD_TABLE]){
    outer->lattice = (PENV->tables[__ADD_TABLE])[table_addsub_index(table, outer->lattice, inner->lattice)];
    outer->epoch += (outer->lattice < inner->lattice) ? 1 : 0;
    return tile_synth(outer);
  } else {
    return tile_synth(dc_lvup(outer));
  }
}

PTile dc_arithmetic_addition(__dc_tile *outer, __dc_tile *inner){
  //swap the order of the two terms to make sure that the outer float appears
  //first.
  if ((outer->inverted) ^ (inner->inverted)) {
    return exact_arithmetic_addition_crossed(outer, inner);
  } else if (outer->inverted) {
    return exact_arithmetic_addition_inverted(outer, inner);
  } else {
    return exact_arithmetic_addition_uninverted(outer, inner);
  }
}

static bool are_inverses(PTile lhs, PTile rhs){
  return tile_additiveinverse(lhs) == rhs;
}

static PTile tile_exact_add(PTile lhs, PTile rhs){
  //redo the checks on this in case we've been passed from inexact_add.
  if (is_tile_inf(lhs))       {return __inf;}
  if (is_tile_inf(rhs))       {return __inf;}
  if (is_tile_zero(lhs))      {return rhs;}
  if (is_tile_zero(rhs))      {return lhs;}
  if (are_inverses(lhs, rhs)) {return __zero;}

  //order lhs vs rhs into inner/outer.
  bool orderswap = __s(tile_abs(lhs)) < __s(tile_abs(rhs));

  DECOMPOSE(rhs)
  DECOMPOSE(lhs)

  __dc_tile *outer = orderswap ? &rhs_dc : &lhs_dc;
  __dc_tile *inner = orderswap ? &lhs_dc : &rhs_dc;

  if (outer->negative ^ inner->negative){
    return dc_arithmetic_subtraction(outer, inner);
  } else {
    return dc_arithmetic_addition(outer, inner);
  }
}

static PTile inexact_add(PTile lhs, PTile rhs, bool upper){
  if (upper){
    return lower_ulp(tile_exact_add(lub(lhs), lub(rhs)));
  } else {
    return upper_ulp(tile_exact_add(glb(lhs), glb(rhs)));
  }
}

PTile tile_add(PTile lhs, PTile rhs, bool upper){
  if (is_tile_inf(lhs)) {return __inf;}
  if (is_tile_inf(rhs)) {return __inf;}
  if (is_tile_zero(lhs)) {return rhs;}
  if (is_tile_zero(rhs)) {return lhs;}

  if (is_tile_exact(lhs) && is_tile_exact(rhs)) {
    return tile_exact_add(lhs, rhs);
  } else {
    return inexact_add(lhs, rhs, upper);
  }
}

void add(PBound *dest, const PBound *lhs, const PBound *rhs){

  /*first handle all the corner cases*/
  if (isempty(lhs) || isempty(rhs)) {set_empty(dest); return;}
  if (isallpreals(lhs) || isallpreals(rhs)) {set_allreals(dest); return;}

  if (issingle(lhs) && issingle(rhs)) {
    //TODO: contemplate adding an exactitude check here.
    dest->state = STDBOUND;

    dest->lower = tile_add(lhs->lower, rhs->lower, false);
    dest->upper = tile_add(lhs->lower, rhs->lower, true);

    collapseifsingle(dest);

    return;
  }

  //assign proxy values because "single" doesn't have a meaningful upper value.
  PTile lhs_upper_proxy = issingle(lhs) ? lhs->lower : lhs->upper;
  PTile rhs_upper_proxy = issingle(rhs) ? rhs->lower : rhs->upper;

  //NB: consider going directly to "single_add" with a double single check.
  //go ahead and do both sides of the bound calculation.  Use a temporary variable.
  dest->state = STDBOUND;
  dest->lower = pf_add(lhs->lower, rhs->lower, false);
  dest->upper = pf_add(lhs_upper_proxy, rhs_upper_proxy, true);

  if (roundsinf(lhs) || roundsinf(rhs)){
    // let's make sure our result still rounds inf, this is a property which is
    // invariant under addition.  Losing this property suggests that the answer
    // should be recast as "allreals."  While we're at it, check to see if the
    // answer ends now "touch", which makes them "allreals".
    if (__s(dest->lower) <= __s(dest->upper)) {
      set_allreals(dest);
    } else if (next(dest->upper) == dest->lower) {
      set_allreals(dest);
    }
  }

  collapseifsingle(dest);
}
