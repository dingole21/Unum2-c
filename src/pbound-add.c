#include "../include/penv.h"
#include "../include/pbound.h"
#include "../include/ptile.h"
#include <stdio.h>

int addsub_index(long long lhs_lattice, long long rhs_lattice){
  //matrix points are generated by shifting away the ulp status.
  int lpoint1 = (lhs_lattice >> 1);
  int lpoint2 = (rhs_lattice >> 1);
  //shift the left value index by the number of lattice bits.
  return (lpoint1 << (PENV->latticebits - 1)) + lpoint2;
}

//addsub index when we have to consider moving between tables.
int table_addsub_index(int table, long long lhs_lattice, long long rhs_lattice){
  int lpoint1 = (lhs_lattice >> 1);
  int lpoint2 = (rhs_lattice >> 1);
  int tablewidth = (1 << (PENV->latticebits - 1));
  return table * tablewidth * tablewidth + (lpoint1 * tablewidth) + lpoint2;
}

static PTile exact_arithmetic_addition_crossed(PTile lhs, PTile rhs){

  int res_epoch = pf_epoch(lhs);
  unsigned long long res_lattice;
  unsigned long long lhs_lattice = pf_lattice(lhs);
  unsigned long long rhs_lattice = pf_lattice(rhs);
  bool res_negative = is_tile_negative(lhs);
  int table = pf_epoch(rhs) + res_epoch;

  if (table < PENV->table_counts[__ADD_CROSSED_TABLE]){
    res_lattice = (PENV->tables[__ADD_CROSSED_TABLE])[table_addsub_index(table, lhs_lattice, rhs_lattice)];
    res_epoch += (res_lattice < lhs_lattice) ? 1 : 0;

    return pf_synth(res_negative, false, res_epoch, res_lattice);
  } else {
    return (res_negative ? prev(lhs) : next(lhs));
  }
}

static PTile exact_arithmetic_addition_inverted(PTile lhs, PTile rhs){

  int res_epoch = pf_epoch(lhs);
  unsigned long long res_lattice;
  unsigned long long lhs_lattice = pf_lattice(lhs);
  unsigned long long rhs_lattice = pf_lattice(rhs);
  bool res_negative = is_tile_negative(lhs);
  bool res_inverted = is_tile_inverted(lhs);
  int table = pf_epoch(rhs) - res_epoch;
  int index = table_addsub_index(table, lhs_lattice, rhs_lattice);

  if (table < PENV->table_counts[__ADD_INVERTED_TABLE]) {
    res_lattice = (PENV->tables[__ADD_INVERTED_TABLE])[index];

    //printf("c says lattice value should be %llX\n", res_lattice);
    //printf("c says res_epoch: %i\n", res_epoch);

    res_epoch -= (res_lattice > lhs_lattice) ? 1 : 0;
  } else {
    return (res_negative ? prev(lhs) : next(lhs));
  }

  if (res_epoch < 0){
    res_inverted = false;
    res_epoch = 0;
    res_lattice = (PENV->tables[__INVERTED_ADD_INVERTED_TABLE])[index];
  }

  //printf("final for c - epoch: %i lattice: %lli \n", res_epoch, res_lattice);

  return pf_synth(res_negative, res_inverted, res_epoch, res_lattice);
}

static PTile exact_arithmetic_addition_uninverted(PTile lhs, PTile rhs){
  int res_epoch = pf_epoch(lhs);
  unsigned long long res_lattice;
  unsigned long long lhs_lattice = pf_lattice(lhs);
  unsigned long long rhs_lattice = pf_lattice(rhs);
  bool res_negative = is_tile_negative(lhs);
  int table = res_epoch - pf_epoch(rhs);

  if (table < PENV->table_counts[__ADD_TABLE]){
    res_lattice = (PENV->tables[__ADD_TABLE])[table_addsub_index(table, lhs_lattice, rhs_lattice)];
    res_epoch += (res_lattice < lhs_lattice) ? 1 : 0;

    return pf_synth(res_negative, false, res_epoch, res_lattice);
  } else {
    return (res_negative ? prev(lhs) : next(lhs));
  }
}

static PTile exact_arithmetic_addition(PTile lhs, PTile rhs){
  //swap the order of the two terms to make sure that the outer float appears
  //first.
  bool orderswap = is_tile_negative(lhs) ^ (__s(lhs) < __s(rhs));

  PTile outer = orderswap ? rhs : lhs;
  PTile inner = orderswap ? lhs : rhs;

  if (is_tile_inverted(outer) ^ is_tile_inverted(inner)) {
    return exact_arithmetic_addition_crossed(outer, inner);
  } else if (is_tile_inverted(outer)) {
    return exact_arithmetic_addition_inverted(outer, inner);
  } else {
    return exact_arithmetic_addition_uninverted(outer, inner);
  }
}

static PTile pf_exact_add(PTile lhs, PTile rhs){

  //redo the checks on this in case we've been passed from inexact_add.
  if (is_tile_inf(lhs))  {return __inf;}
  if (is_tile_inf(rhs))  {return __inf;}
  if (is_tile_zero(lhs)) {return rhs;}
  if (is_tile_zero(rhs)) {return lhs;}

  if (is_tile_negative(lhs) ^ is_tile_negative(rhs)){
    return exact_arithmetic_subtraction(lhs, tile_additiveinverse(rhs));
  } else {
    return exact_arithmetic_addition(lhs, rhs);
  }
}

static PTile pf_inexact_add(PTile lhs, PTile rhs, bool upper){
  if (upper)
    return lower_ulp(pf_exact_add(lub(lhs), lub(rhs)));
  else
    return upper_ulp(pf_exact_add(glb(lhs), glb(rhs)));
}

PTile tile_add(PTile lhs, PTile rhs, bool upper){
  if (is_tile_inf(lhs)) {return __inf;}
  if (is_tile_inf(rhs)) {return __inf;}
  if (is_tile_zero(lhs)) {return rhs;}
  if (is_tile_zero(rhs)) {return lhs;}

  if (is_tile_exact(lhs) && is_tile_exact(rhs)) {
    return pf_exact_add(lhs, rhs);
  } else {
    return pf_inexact_add(lhs, rhs, upper);
  }
}

void add(PBound *dest, const PBound *lhs, const PBound *rhs){

  /*first handle all the corner cases*/
  if (isempty(lhs) || isempty(rhs)) {set_empty(dest); return;}
  if (isallpreals(lhs) || isallpreals(rhs)) {set_allreals(dest); return;}

  if (issingle(lhs) && issingle(rhs)) {
    //TODO: contemplate adding an exactitude check here.
    dest->state = STDBOUND;

    dest->lower = tile_add(lhs->lower, rhs->lower, false);
    dest->upper = tile_add(lhs->lower, rhs->lower, true);

    collapseifsingle(dest);

    return;
  }

  //assign proxy values because "single" doesn't have a meaningful upper value.
  PTile lhs_upper_proxy = issingle(lhs) ? lhs->lower : lhs->upper;
  PTile rhs_upper_proxy = issingle(rhs) ? rhs->lower : rhs->upper;

  //NB: consider going directly to "single_add" with a double single check.
  //go ahead and do both sides of the bound calculation.  Use a temporary variable.
  dest->state = STDBOUND;
  dest->lower = pf_add(lhs->lower, rhs->lower, false);
  dest->upper = pf_add(lhs_upper_proxy, rhs_upper_proxy, true);

  if (roundsinf(lhs) || roundsinf(rhs)){
    // let's make sure our result still rounds inf, this is a property which is
    // invariant under addition.  Losing this property suggests that the answer
    // should be recast as "allreals."  While we're at it, check to see if the
    // answer ends now "touch", which makes them "allreals".
    if (__s(dest->lower) <= __s(dest->upper)) {
      set_allreals(dest);
    } else if (next(dest->upper) == dest->lower) {
      set_allreals(dest);
    }
  }

  collapseifsingle(dest);
}
